# Иструкция для Git
## Инициализация репозитория  
* Инициализировать репозиторий можно с помощью команды **git init**.
* Проверить статус, или состояние, репозитория поможет команда **git status**.
* Если вы ошиблись и случайно инициализировали не ту папку, можно «разгитить» её — удалить скрытую подпапку .git. С помощью команды **rm -rf .git**.  


*Разберём подробнее, что такое -rf:*  
    - ключ **-r** (от англ. recursive — «рекурсивно») позволяет удалять папки вместе с их содержимым;  
    - ключ **-f** (от англ. force — «заставить») избавит вас от вопросов вроде «Вы точно хотите удалить этот файл? А этот? И этот тоже?».  

## Добавление файлов в репозиторий
* Команда **git add** позволяет подготовить файл к сохранению.  
* Команда **git add --all** подготовит к сохранению сразу все файлы.  
* С помощью **git add .** можно добавить в репозиторий текущую папку со всеми файлами.  

## Коммит (commit)
### Создание коммита
Коммит гарантирует, что изменения будут сохранены в истории и при необходимости к ним можно будет «откатиться».  
* Коммит можно сделать с помощью команды **git commit**.
* Ключ **-m** позволяет присвоить коммиту сообщение.  Помните, что такие сообщения должны быть информативными: чётко описывать изменения.
* В коммит попадает то, что было предварительно добавлено командой **git add** перед коммитом.

```bash
$ git commit -m 'Мой первый коммит!' 
```

### История коммитов
Чтобы увидеть историю коммитов, введите команду **git log** (от англ. log — «журнал [записей]»).  
Обратите внимание, что по умолчанию git log выводит коммиты в обратном хронологическом порядке — последние коммиты оказываются первыми сверху. В этом можно убедиться, если посмотреть на дату и время их создания.

## GitHub
GitHub — платформа, которая работает с Git и упрощает командное взаимодействие.  
Кроме GitHub, существуют и другие подобные платформы, например GitLab, Bitbucket и так далее.  
Git — это консольный инструмент для работы с локальными и удалёнными репозиториями. Он не связан напрямую ни с одной из платформ и развивается отдельно от них.  

* Чтобы связать локальный репозиторий с GitHub, нужно сначала создать репозиторий на GitHub (желательно с таким же именем)
* сгенерировать SSH-ключи
* затем действовать по инструкции: 
```bash
echo "# -" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin git@github.com:Username/name-repository.git
git push -u origin main
```
### SSH-ключ
#### Что такое SSH
Когда компьютеры обмениваются данными в сети, они следуют сетевым протоколам (англ. network protocols) — правилам обмена данными между компьютерами.  
Один из наиболее распространённых сетевых протоколов — SSH (от англ. Secure Shell Protocol). Он обеспечивает безопасный обмен данными в сети. С помощью этого протокола можно получать данные с удалённого компьютера или отправлять их на него. Трафик шифруется, поэтому протокол безопасен.  
SSH использует пару ключей для обеспечения безопасности — публичный и приватный: 
  * Приватный ключ (англ. private key) хранится только на вашем компьютере и не должен передаваться кому-либо ещё. Он используется для расшифровки данных.  
  * Публичный ключ (англ. public key) доступен всем и используется для шифрования данных. Они могут быть расшифрованы парным приватным ключом.  

Только вы можете расшифровать данные с помощью приватного ключа, но любой владелец публичного ключа может их для вас зашифровать. Эти два ключа связаны и образуют SSH-пару. В будущем вы наверняка будете использовать их для взаимодействия с GitHub и другими удалёнными серверами.  

1. Проверка начличия SSH-ключей
Ввести команду **ls -la .ssh/ **. Если папка пустая или её нет, всё в порядке.   
Если есть файлы с похожими названиями, SSH-ключи уже создавались:
- id_dsa.pub;
- id_ecdsa.pub;
- id_ed25519.pub;
- id_rsa.pub.

2. Генерация SSH-ключей
* Для генерации SSH-пары можно использовать программу ssh-keygen. Для этого нужно ввести команду: **ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"**
    - Если вышло сообщение об ошибке, то, скорее всего, ваша система не поддерживает алгоритм шифрования ed25519. Используйте другой алгоритм: **ssh-keygen -t rsa -b 4096 -C**.  
* После сообщения "> Generating public/private rsa key pair." нужно указать место хранения ключей. Простой вариант — сделать домашний каталог пользователя путём по умолчанию. Для этого нажмите Enter.
* Программа запросит кодовую фразу (англ. passphrase) для доступа к SSH-ключу. Вы можете оставить поле пустым. Для этого нажмите Enter, а затем ещё раз Enter для подтверждения.
* Проверить, что ключи действительно сгенерировались: **ls -a ~/.ssh**. Должно появиться 2 файла — один с расширением .pub, другой — без. Файл в .pub — публичный, им можно делиться с веб-сайтами или коллегами. Файл без расширения .pub — приватный. Ни в коем случае не передавайте его никому! 

3. Привязать SSH-ключ к GitHub
* Скопируйте содержимое файла с публичным ключом в буфер обмена командой: ** clip < ~/.ssh/id_rsa.pub** или **clip < ~/.ssh/id_ed25519.pub** (в зависимости от метода шифрования). Если не получилось - тогда открыть файл с помощью **cat** и скопировать.
* Перейдите на GitHub и выберите пункт Settings (англ. «настройки») в меню аккаунта. 
* В меню слева нажмите на пункт SSH and GPG keys.
* В открывшейся вкладке выберите New SSH key (англ. «новый SSH-ключ»).
* В поле Title (англ. «заголовок») напишите название ключа. Например, Personal key (англ. «личный ключ»).  
В поле Key type (англ. «тип ключа») должно быть Authentication Key (англ. «ключ аутентификации»).  
В поле Key скопируйте ваш ключ из буфера обмена.
* Нажмите на кнопку Add SSH key (англ. «добавить SSH-ключ»).  
* Проверьте правильность ключа с помощью следующей команды: **ssh -T git@github.com**.   
Если это первый раз, когда вы используете Git, чтобы поделиться проектом на GitHub, появится похожее предупреждение:  "The authenticity of host 'github.com (140.82.121.4)' can...".  
Вы можете проверить ключи GitHub по этой ссылке. Если ключ в предупреждении совпадает с тем, что вы видите на сайте, значит, сервер является действительным. Введите yes, чтобы продолжить. Вы увидите приветствие на экране.  

### Связывание удалённого репозитония к локальному
1. Перейдите на страницу удалённого репозитория, выберите тип SSH и скопируйте URL. Кнопка справа позволит сделать это мгновенно.
2. Откройте консоль, перейдите в каталог локального репозитория и введите команду **git remote add** (от англ. remote — «удалённый» и add — «добавить»). Пример:
```bash
$ git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git 
```

Команде необходимо передать два параметра: имя удалённого репозитория и его URL. В качестве имени используйте слово origin. А URL вы скопировали со страницы удалённого репозитория.  

3. Убедиться, что репозитории связаны можно командой: **git remote -v**. Должно вывести 2 одинаковые строчки.  
Флаг -v — короткая форма флага --verbose (англ. «подробный»). Он позволяет показать больше информации в выводе.  

### Синхронизация репозиториев
* Коммиты хранятся в ветках. Начальная ветка создаётся автоматически и называется main или master.  
* За отправку изменений на удалённый репозиторий отвечает команда **git push**.  
В первый раз эту команду нужно вызвать с флагом **-u** и параметрами **origin** (имя удалённого репозитория) и main или master (название текущей ветки). Флаг **-u** свяжет локальную ветку с одноимённой удалённой. Как вы связывали локальный и удалённый репозитории в предыдущем уроке, так же и здесь нужно дополнительно связать ветки. Пример:
``` bash
git push -u origin main 
```

* Интерфейс GitHub позволяет удобно просмотреть все коммиты в репозитории, а также изменения в этих коммитах.

### Файл README.md
Как правило, в README.md проекта можно найти следующую информацию:  
1. Название проекта и его краткое описание: кем создан, для чего, какие решает задачи и какие закрывает проблемы.  
2. Технологии, которые применяются в проекте. В чём его отличие от аналогичных.  
3. Документация проекта — подробная инструкция о том, что представляет собой проект.  
4. Планы проекта, если они есть.  

Руководство по маркдауну по [ссылке]( https://www.markdownguide.org/cheat-sheet/)

### Хэш
Git преобразует информацию о коммитах с помощью алгоритма SHA-1 и для каждого из них рассчитывает уникальный идентификатор — хеш.  
Хеш — основной идентификатор коммита и позволяет узнать его автора, дату и содержимое закоммиченных файлов.  
Все хеши, а также таблицу соответствий хеш → информация о коммите Git хранит в папке .git.  

#### Логи
Лог - это от англ. log — «журнал [записей]». Он хранит описание коммита. Сокращённый лог полезен, если нужно быстро найти нужный коммит среди сотни других.  
1. Элементы описания коммита. После вызова **git log** появляется список коммитов.  
Описание состоит из:  
* строка из цифр и латинских букв после слова commit — это хеш коммита;  
* Author — имя автора и его электронная почта;  
* Date — дата и время создания коммита;  
* в конце находится сообщение коммита.  

2. Получить сокращённый лог — **git log --oneline**. В терминале появятся только первые несколько символов хеша каждого коммита и их комментарии.  
Сокращённый лог полезен, если в репозитории уже много коммитов — например, сотни или тысячи. В этом случае можно быстро найти нужный по описанию.  
Сокращённый хеш (то есть первые несколько символов полного) можно использовать точно так же, как и полный. Для этого команда git log --oneline автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.  

Обратите внимание: если выход из просмотра логов не произошёл автоматически, нажмите клавишу **Q** (от англ. Quit — «выйти») в английской раскладке клавиатуры.  

#### Файл HEAD
Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый).  
Когда вы делаете коммит, Git обновляет refs/heads/master — записывает в него хеш последнего коммита. Получается, что HEAD тоже обновляется, так как ссылается на refs/heads/master.  
При работе с Git указатель HEAD используется довольно часто. Мы уже упоминали, что многие команды Git принимают в качестве параметра хеш коммита. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит.  

#### Статусы untracked/tracked, staged и modified
* Статусом untracked помечается файл, о существовании которого Git знает, но не следит за изменениями в нём. Этот статус — противоположность tracked, в который попадают все файлы, отслеживаемые Git.  
* Файл переходит в статус staged после выполнения git add.  
* Статус modified означает, что файл был изменён.  
* Большинство файлов в проектах «шагает» по следующему циклу: «изменён» → «добавлен в список на коммит» → «закоммичен» → «изменён» → и так далее.  

#### git status
Большинство файлов в типичном проекте будут находиться в состоянии tracked (то есть закоммичены и не изменены после коммита). Вы не увидите это состояние в выводе команды **git status** — иначе она бы каждый раз выводила список вообще всех файлов проекта.  
В итоге git status показывает только следующие состояния файлов:  
* staged (Changes to be committed в выводе git status);  
* modified (Changes not staged for commit);  
* untracked (Untracked files).  

Команда git status всегда подскажет, что происходит с файлом: например, он добавлен в список «на коммит» или ещё вообще не отслеживается, или изменён.  
git status показывает явно следующие состояния файлов: untracked, staged и modified.  
git status подсказывает, какие команды можно выполнить, чтобы поменять состояние файла.  

### Сообщения коммита
Правильно описывать коммиты — искусство, к которому стоит приобщиться как можно раньше. Хорошо, когда:  
* сообщение коммита легко читается;  
* оно информативное;  
* все сообщения оформлены в одном стиле.

### Исправление последнего коммита
* команда **--amend** рассчитана на работу с последним коммитом (HEAD).
* дополнить коммит новыми файлами можно с помощью **git commit --amend --no-edit**. Благодаря опции --no-edit сообщение к коммиту останется таким, каким и было.
* изменить сообщение к коммиту позволяет команда **git commit --amend -m "Обновлённое сообщение коммита"**.

### Отменить изменения или откатить коммит
* Команда **git restore --staged <file>** переведёт файл из staged обратно в modified или untracked.
* Команда **git reset --hard <commit hash>** «откатит» историю до коммита с хешем <hash>. Более поздние коммиты потеряются!
* Команда **git restore <file>** «откатит» изменения в файле до последней сохранённой (в коммите или в staging) версии.

### Просмотр изменений коммита
* Команда **git diff** сравнит последнюю закоммиченную версию файла с той, что находится в состоянии modified.
* Команда **git diff --staged** покажет изменения в staged-файлах относительно последних закоммиченных версий.
* Команда **git diff A B** выводит список инструкций: как превратить состояние A в состояние B (А и В здесь хеши коммитов, последний коммит можно записать как HEAD). 

### Дописать строку в файл
* Команда **echo "Вторая строка файла" >> file.txt** добавит в конец файла file.txt строку "Вторая строка файла".
* Команда **echo "Вторая строка файла" > file.txt** удалит всё содержимое файла file.txt  и добавит строку "Вторая строка файла".

### .gitignore
* Если нужно, чтобы Git игнорировал какие-то файлы, стоит составить файл .gitignore.
* Посмотреть, что игнорируется, можно с помощью команды **git status --ignored**.
* Сам файл .gitignore — это обычный файл в репозитории. Его тоже стоит закоммитить.
* Шаблонов много, но их легко найти в интернете вместе с примерами использования:
    "#" - с решётки начинается комментарий
    "название файла" - файл с таким названием игнорируется, 1 строка - 1 файл
    "*" - соответствует любой строке включая пустую (заменяет любое количество любых символов, например: *.jpg)
    "?" - соответствует одному любому символу (например: file?.txt - любой файл с именами типа file1.txt, fileB.txt, но не file21.txt, fileAAA.txt)
    "[]" - соответсвует одному определённому символу из указанных в скобках (например: file[0-2].txt или file[a-z].txt)
    "/" - указывает на каталоги. Если шаблон в .gitignore начинается со слеша, то Git проигнорирует файлы или каталоги только в корневой директории. Если шаблон заканчивается слешем, то правило применится только к папке. Примеры: /todo.txt (игнорим файл в корневом каталоге) и build/ (игнорим все файлы в папке build)
    "**" - похожа на функцию одинарной ( * ). Отличие в том, как они работают с вложенными папками. Двойная звёздочка может соответствовать любому количеству таких папок (в том числе нулю). Одинарная может соответствовать только одной. Например: docs/ **/tmp (лишний пробел добавлен, чтобы не выделялось полужирным)
    "!" - инвертирует любое правило в файле .gitignore. Например: *.jpeg, !doge.jpeg (игнорируем все файлы jpg кроме doge)

### Клонирование репозитория
* Команда **git clone** копирует проект на локальный компьютер.
* Команда **git clone** автоматически связывает локальный репозиторий с удалённым.

### Ветки разработки
* Ветка — это последовательность независимых изменений.
* Благодаря веткам несколько человек могут работать над одним репозиторием и не мешать друг другу. А ещё ветки помогают декомпозировать большую и страшную задачу на маленькие и понятные.
* Основная версия проекта хранится в главной ветке main (или master).
* С помощью команды **git branch** можно посмотреть, какие в проекте есть ветки и в какой из них вы сейчас находитесь.
* Создавать ветки с помощью команды **git branch <название_ветки>**. Ветки в Git — удобный инструмент. В каждой может быть сколько угодно коммитов, а когда работа будет сделана, останется только объединить их.
* Команда **git checkout <название_ветки>** позволяет переключаться на другую ветку.
* Разные ветки в одном проекте существуют независимо. Изменения в одной не влияют на изменения в другой.
* В Git можно создать ветку и сразу же перейти в неё командой **git checkout -b <название_ветки>**.
* Ветка указывает на коммит, который сделан в ней последним. При этом две ветки могут ссылаться на один и тот же коммит — например, если вы только что создали ветку, но ещё не успели внести в неё коммит.
* Посмотреть и локальные, и удалённые ветки можно с помощью команды **git branch -a**.

#### Сравнение изменений в ветках
* Команда **git diff** может сравнивать ветки по их названиям. Например, команда **git diff main feature/my-feature** выведет разницу между основной веткой и веткой feature/my-feature.
* Git поддерживает суффикс навигации ~. С его помощью можно сослаться на предыдущие коммиты. Например, если вы находитесь в ветке main и хотите вывести разницу между тем коммитом, который был три коммита назад, и текущим, нужно выполнить **git diff main~3 main**.

#### Слияние веток
* Выполнить слияние веток позволяет команда **git merge <название_ветки>**. В качестве параметра указывают название ветки, которую нужно влить в текущую. Перейти в основную ветку -> выполнить команду с названием ветки, которая вливается в основную.
* Удалять ненужные ветки после слияния — хорошая практика. Так в вашем репозитории всегда будет порядок. За удаление веток отвечает команда **git branch -D <название_ветки>** и её щадящий вариант с флагом **-d**, где контролируется было ли слияние удаляемой ветки с основной, если нет - выдаст ошибку.

#### Конфликт слияния
Конфликты чаще всего возникают, когда несколько программистов одновременно меняют код в одном и том же месте. Тогда при слиянии веток Git не может автоматически объединить две версии файла, т.к. не знает какие изменения принять. Здесь может разобраться только человек, нужно сделать следующее:
1. Заглянуть в файл, где произошёл конфликт.
2. Изучить обе стороны конфликта — вашу версию и версию вашего коллеги. Ваша задача — правильно собрать две версии в итоговую, так чтобы изменения обеих сторон не потерялись. Новая версия станет текущей актуальной.
3. Вручную удалить или подправить неактуальные изменения, если они есть.
4. Подготовить изменения к сохранению и сделать коммит.

#### Push
Команда **git push** «толкает» коммиты из локальной ветки в её удалённую копию.
Допустим, вы находитесь в ветке main в локальном репозитории и выполняете git push. В результате все новые коммиты из локальной ветки main попадут в ветку main в репозитории на GitHub. После этого локальная и удалённая ветки будут содержать одни и те же коммиты.
Хотя git push не выполняет слияния веток, для этой команды тоже важно состояние fast-forward, но специфическое: между локальной веткой (откуда берутся коммиты для push) и удалённой (куда эти коммиты попадут).

### Пул-руквест
* Пул-реквест — это запрос на рассмотрение предлагаемых изменений и часть процесса ревью.
* Запрос на изменения можно инициировать двумя способами: через ссылку, которую Git выводит после создания ветки, или через интерфейс GitHub.
* После создания пул-реквеста ваши коллеги сделают ревью — оценят предложенные вами правки и оставят свои комментарии.
* По результатам ревью ваши правки могут быть приняты в основную ветку проекта или возвращены на доработку.

У каждого пул-реквеста есть:
_Название_ — краткое описание предлагаемых изменений. Например: Адаптивный заголовок сайта, Замена альбома на галерею и так далее.
_Описание_ — развёрнутое описание изменений. Это поле заполнять необязательно, но желательно.
_Исходная ветка_ — та, в которой вы работали. Например, feature/merge-request.
_Целевая ветка_ — основная ветка проекта, в которую вы хотите внести изменения.

Также у каждого пул-реквеста может быть два исхода:
_merge_ (англ. «соединить») — предлагаемые изменения приняты; код вливается в целевую ветку; пул-реквест закрывается.
_close_ (англ. «закрыть») — пул-реквест закрывается без слияния изменений.

### Пулл - забрать изменения из удалённого репозитория
Алгоритм:
1. Сначала нужно перейти в локальный репозиторий и убедиться, что вы находитесь в правильной ветке, — как правило, это основная ветка main (или master). 
2. Ввести команду **git pull**. Обычно git pull — это первая команда, которую вводит разработчик, как только открывает код проекта, чтобы начать с ним работать.
Дополнительно **git pull** и **git merge** выполняют перед тем, как создать пул-реквест. Перед созданием пул-реквеста рекомендуется сначала подтянуть изменения из основной ветки, объединить их с вашей, решить все возможные конфликты и лишь затем сделать push.
``` bash
$ git checkout main # перешли в main
$ git pull # подтянули новые изменения в main
$ git checkout my-branch # вернулись в рабочую ветку my-branch
$ git merge main # влили main в новую ветку my-branch
$ git push -u origin my-branch # отправили ветку my-branch в удалённый репозиторий 
```

## Состояние fast-forward
* Если истории двух веток не «разошлись» и их коммиты выстраиваются в одну цепочку, эти ветки можно объединить в режиме fast-forward.
* Режим fast-forward можно отключить с помощью флага --no-ff.

## Состояние non-fast-forward
* Если истории двух веток всё же «разошлись», при слиянии веток Git создаст коммит слияния.
* При объединении веток в состоянии не-fast-forward возможны (но не обязательны) конфликты. Если конфликты всё же возникли, Git попытается разрешить их самостоятельно или попросит вас сделать это вручную.

## Конфликты
* Конфликты — это ситуация, в которой две ветки или более изменяют один и тот же файл в разных местах и пытаются объединиться в одну ветку.
* При возникновении конфликта Git добавит в файлы маркеры конфликтов. Вы можете разрешить конфликт вручную: достаточно удалить маркеры и принять правильные изменения.
* Для разрешения конфликтов вы также можете использовать vimdiff — он доступен по умолчанию. Вызывается командой **git mergetool**.

## Псевдонимы команд
Смотри документацию [https://git-scm.com/book/en/v2/Git-Basics-Git-Aliases].

